## 2. 컴포넌트 생성해보기
### 화살표 함수(Arrow Function)
``` jsx
const MyComponent = () => {
    return <div>Test Component</div>;
};

export default MyComponent;
```
- 일반 함수는 자신이 종속된 객체를 this로 가리키며, 화살표 함수는 자신이 종속된 인스턴스를 카리킴.
- 화살표 함수는 값을 연산하여 바로 반환해야 할 때 사용하면 가독성이 높아짐.
- 함수 컴포넌트를 선언할때 function 키워드를 사용해도 되고, 화살표 함수를 선언하여도 됨.

### 모듈 내보내기 및 불러오기
``` jsx
export default MyComponent;
```
- 이 코드는 다른 파일에서 이 파일을 import할 때, 위에서 선언한 MyComponent 클래스를 불러오도록 설정함.
``` jsx
import MyComponent from './MyComponent';

const App = () => {
  return <MyComponent />;
}

export default App;
```
- 선언한 MyComponent를 import하여 App.js에서 사용함.
<br>

## 3. props
- props는 컴포넌트 속성을 설정할 때 사용하는 요소임.
- props 값은 해당 컴포넌트를 불러와 사용하는 부모 컴포넌트에서 설정할 수 있음.

### JSX 내부에서 props 렌더링
``` jsx
const MyComponent = props => {
  return <div>Hello, My name is {props.name}</div>;
};
  
export default MyComponent;
```
- props 값은 컴포넌트 함수의 파라미터로 받아와서 사용할 수 있음.
- props를 렌더링 할때 JSX 내부에서 { } 기호로 감싸주면 됨.

### 컴포넌트 사용시 props 값 지정하기
``` jsx
import MyComponent from './MyComponent.js';

const App = () => {
  return <MyComponent name="React"/>;
}

export default App;
```

### props 기본값 설정: defaultProps
``` jsx
const MyComponent = props => {
  return <div>Hello, My name is {props.name}</div>;
};
MyComponent.defaultProps = {
  name: 'Default Name'
}

export default MyComponent;
```
- 위와 같이 defaultProps로 기본 값을 지정해주면, App.js에서 MyComponent에 props설정을 하지 않았을때 default값을 보여줄 수 있음.

### 태그 사이의 내용을 가져오기: props.children
``` jsx
const MyComponent = props => {
    return (
        <div>
            Hello, My name is {props.name}. <br/>
            Children Value is {props.children}.
        </div>
    );
};
MyComponent.defaultProps = {
    name: 'Default Name'
}

export default MyComponent;
```
``` jsx
import MyComponent from './MyComponent.js';

const App = () => {
  return <MyComponent>Test Children</MyComponent>;
}

export default App;
```
- 위와 같이 MyComponent에서 props.children 를 선언해놓으면, App.js에서 태그 사이의 내용을 보여줄 수 있음.

### 비구조화 할당 문법을 통해 props 내부 값 추출하기
- MyComponent에서 props 값을 조회할 때, props.라는 키워드를 붙여주고 있음.
- 이는 ES6의 비구조화 할당 문법을 사용하여 내부 값을 바로 추출할 수 있음.
``` jsx
const MyComponent = props => {
    const { name, children } = props;
    return (
        <div>
            Hello, My name is {name}. <br/>
            Children Value is {children}.
        </div>
    );
};
MyComponent.defaultProps = {
    name: 'Default Name'
}

export default MyComponent;
```
- 이처럼 객체에서 값을 추출하는 문법을 비구조화 할당(destructuring assignment)이라고 함.
- 이 문법은 구조 분해 문법이라고도 불리며, 함수의 파라미터 부분에서도 사용할 수 있음.
``` jsx
const MyComponent = ({ name, children }) => {
    return (
        <div>
            Hello, My name is {name}. <br/>
            Children Value is {children}.
        </div>
    );
};
MyComponent.defaultProps = {
    name: 'Default Name'
}

export default MyComponent;
```
- 위처럼 비구조화 할당 문법을 사용하면 props를 쉽게 사용할 수 있음.

### (추가) props.defaultProps 선언 방식 변경
``` jsx
import PropTypes from 'prop-types';

const MyComponent = ({ name = 'Default Name', children }) => {
    return (
        <div>
            Hello, My name is {name}. <br/>
            Children Value is {children}.
        </div>
    );
};

export default MyComponent;
```
- react 18.3버전부터는 defaultProps의 선언방식이 변경되었음.

### propTypes를 통한 props 검증
``` jsx
import PropTypes from 'prop-types';

const MyComponent = ({ name = 'Default Name', children }) => {
    return (
        <div>
            Hello, My name is {name}. <br/>
            Children Value is {children}.
        </div>
    );
};
MyComponent.propTypes = {
    name: PropTypes.string
};

export default MyComponent;
```
- PropTypes를 통해 name값을 항상 문자열 형태로 전달하게 하였음.
- App.js에서 name에 문자열이 아닌 값을 설정할 경우, console에 오류 메시지를 출력함.

### isRequired를 사용하여 필수 propTypes 설정
``` jsx
import PropTypes from 'prop-types';

const MyComponent = ({ name = 'Default Name', age, children }) => {
    return (
        <div>
            Name is {name}. <br/>
            Age is {age}. <br/>
            Children Value is {children}.
        </div>
    );
};
MyComponent.propTypes = {
    name: PropTypes.string,
    age: PropTypes.number.isRequired
};

export default MyComponent;
```
- isRequired를 설정할 경우 App.js에서 MyComponent를 사용할때 age 값을 지정하지 않으면 console에 에러를 출력함.

### 자주 사용하는 PropTypes 종류
- array: 배열
- arrayOf(다른 PropType): 특정 PropType으로 이루어진 배열
- bool: true 혹은 false 값
- func: 함수
- number: 숫자
- object: 객체
- string: 문자열
- symbol: ES6의 Symbol
- node: 렌더링할 수 있는 모든 것(숫자, 문자열, JSX코드, children, ...)
- instansOf(클래스): 특정 클래스의 인스턴스
- oneOf(['A', 'B']): 주어진 배열 요소 값 중 하나
- oneOfType([React.PropType.string, PropTypes.number]): 주어진 배열안의 종류중 하나
- objectOf(React.PropTypes.number): 객체의 모든 키 값이 인자로 주어진 PropType인 객체
- shape({ name: PropTypes.string, num: PropTypes.number }): 주어진 스키마를 가진 객체
- any: 아무 종류

### 클래스형 컴포넌트에서 props 사용하기
``` jsx
import { Component } from 'react';
import PropTypes from 'prop-types';

class MyComponent extends Component {
    render() {
        const { name = 'Default Name', age, children } = this.props; // 비구조화 할당
        return (
            <div>
                Name is {name}. <br/>
                Age is {age}. <br/>
                Children Value is {children}.
            </div>
        );
    }
}
MyComponent.propTypes = {
    name: PropTypes.string,
    age: PropTypes.number.isRequired
};

export default MyComponent;
```
- 클래스형 컴포넌트에서 props를 사용할 때는 render 함수에서 this.props를 조회하면 됨.
- defaultProps와 propTypes는 똑같은 방식으로 설정할 수 있음.
``` jsx
import { Component } from 'react';
import PropTypes from 'prop-types';

class MyComponent extends Component {
    static defaultProps = {
        name: 'Default Name'
    };
    static propTypes = {
        name: PropTypes.string,
        age: PropTypes.number.isRequired
    };
    render() {
        const { name, age, children } = this.props; // 비구조화 할당
        return (
            <div>
                Name is {name}. <br/>
                Age is {age}. <br/>
                Children Value is {children}.
            </div>
        );
    }
}

export default MyComponent;
```
- 클래스형 컴포넌트에서 defaultProps와 propTypes를 설정할 때 class 내부에서 지정할 수도 있음.
