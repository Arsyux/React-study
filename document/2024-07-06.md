# 2장 JSX

## 1. 코드 이해하기
``` jsx
import logo from './logo.svg'; 
import './App.css'; 

function App() { 
 return ( 
   <div className="App"> 
     <header className="App-header"> 
       <img src={logo} className="App-logo" alt="logo" /> 
       <p> 
         Edit <code>src/App.js</code> and save to reload. 
       </p> 
       <a 
         className="App-link" 
         href="https://reactjs.org" 
         target="_blank" 
         rel="noopener noreferrer" 
       > 
         Learn React 
       </a> 
     </header> 
   </div> 
 ); 
} 

export default App; 
```
- import기능은 Node.js에서 지원하는 기능임. Node.js에서는 import가 아닌 require라는 구문으로 패키지를 불러올 수 있음.
- 이러한 기능을 브라우저에서도 사용하기 위해 번들러(bundler)를 사용함.
- 번들러 도구를 사용하면 import(또는 require)로 모듈을 불러왔을 때 불러온 모듈을 모두 합쳐서 하나의 파일을 생성해 줌.
- 대표적인 번들러로 웹팩, Parcel, browserify라는 도구들이 있으며 리액트에서는 주로 웹팩을 사용함.
- 최적화 과정에서 여러 개의 파일로 분리 될 수도 있음.
- 프로젝트에서는 src/index.js를 시작으로 필요한 파일을 다 불러와서 번들링하게 됨.
- 2017년부터 브라우저에서도 import 구문을 사용할 수 있게 되었지만, 이는 단순히 다른 경로에 있는 자바스크립트를 불러오는 용도로만 사용 됨.
- 웹팩의 로더라는 기능은 SVG 파일과 CSS 파일도 불러와서 사용할 수 있게 해줌.
- function 키워드를 사용하여 만들어진 컴포넌트를 함수 컴포넌트라고 부름.
- 프로젝트에서 컴포넌트를 렌더링하면 함수에서 반환하고 있는 내용을 나타냄.
- 함수의 내용이 HTML코드를 작성한 것 같지만, 이 코드는 JSX라고 부름.
<br>

### 2. JSX란?
- JSX는 자바스크립트의 확장 문법이며 XML과 비슷하게 생겼음.
- JSX 코드는 브라우저에서 실행되기 전에 코드가 번들링되는 과정에서 바벨을 사용하여 일반 자바스크립트 형태의 코드로 변환됨.
``` jsx
function App() {
  return (
    <div>
      Hello <b>react</b>
    </div>
  );
}
```
- 이 코드는 다음과 같이 변환됨
``` javascript
function App() {
  return React.createElement("div", null, "Hello ", React.createElement("b", null, "react"));
}
```
<br>

### 3. JSX의 장점
- 가독성이 좋다
- JSX에서는 HTML 태그 뿐만 아니라 컴포넌트도 JSX 안에서 작성할 수 있음.
- src/index.js 파일에서 App 컴포넌트를 작성하고 App.js에서는 App 컴포넌트를 만듬.
https://github.com/Arsyux/React-study/blob/65476c5a6d1d99fa3b21360e17d3eac4cfde4321/example/hello-react/src/index.js#L1-L17
- document.getElementById를 이용하여 public/index.html에서 id가 root인 HTML 요소를 찾고, 리액트 컴포넌트를 보여줄 수 있는 루트 인스턴스를 createRoot 함수를 사용하여 생성함. 
  그리고 root.render 함수에 JSX 코드를 인자로 넣어서 보여주고 싶은 컴포넌트를 화면에 보여줌.
- React.StrictMode 컴포넌트는 레거시 기능을 사용할 때 경고를 주고, 향후 버전에 도입될 기능들이 정상적으로 호환될 수 있도록 유도하는 개발환경에서만 활성화되는 디버깅용 컴포넌트임.
- reportWebVitals()는 웹 성능을 측정하는 도구임.
<br>

### 4. JSX 문법
#### 감싸인 요소
- 컴포넌트에 여러 요소가 있다면 반드시 부모 요소 하나로 감싸야 함.
``` jsx
function App() {
  return (
    <h1>Hello!</h1>
    <h2>React!</h2>
  );
}

export default App;
```
- 위 코드는 요소 여러 개가 부모 요소 하나에 의해 감싸여 있지 않기 때문에 오류가 발생함.
``` jsx
function App() {
  return (
    <div>
      <h1>Hello!</h1>
      <h2>React!</h2>
    </div>
  );
}

export default App;
```
- 다음과 같이 div로 감싸주면 해결 할 수 있음.
- 위와 같이 감싸주는 이유는 VirtualDOM에서 컴포넌트 변화를 감지해 낼 때 효율적으로 비교할 수 있도록 컴포넌트 내부는 하나의 DOM 트리 구조로 이루어져야 한다는 규칙 때문임.
- div를 사용하고 싶지 않은 경우 Fragment라는 기능을 사용할 수 있음 (v16 이상)
``` jsx
import { Fragment } from 'react';

function App() {
  return (
    <Fragment>
      <h1>Hello!</h1>
      <h2>React!</h2>
    </Fragment>
  );
}

export default App;
```
- Fragment는 다음과 같은 형태로도 표현할 수 있음.
``` jsx
import { Fragment } from 'react';

function App() {
  return (
    <>
      <h1>Hello!</h1>
      <h2>React!</h2>
    </>
  );
}

export default App;
```
