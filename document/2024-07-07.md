## 5. 자바스크립트 표현
- JSX 안에서는 자바스크립트 표현식을 쓸 수 있음.
- 자바스크립트 표현식을 작성하려면 JSX 내부에서 코드를 { }로 감싸면 됨.
``` jsx
function App() {
  const name = '테스트';
  return (
    <>
      <h1>Hello!</h1>
      <h2>{name}!</h2>
    </>
  );
}

export default App;
```
- 변수를 선언할때 기본적으로 const를 사용하고 해당 값이 변경이 필요한 경우는 let을 사용함.
<br>

## 6. if문 대신 조건부 연산자
- JSX 내부의 자바스크립트 표현식에서 if을 사용할 수 없음.
- 조건에 따라 다른 내용을 렌더링해야 할 때는 JSX 밖에서 if 문을 사용하여 사전에 값을 설정하거나, { } 안에 조건부 연산자를 사용함.
``` jsx
function App() {
  const name = "테스트";

  return (
    <>
      <h1>name의 값: {name}</h1>
      {name==='테스트'? (
        <h1>테스트입니다.</h1>
      ):(
        <h1>테스트가 아닙니다.</h1>
      )}
    </>
  );
}

export default App;
```
<br>

## 7. AND 연산자(&&)를 사용한 조건부 렌더링
``` jsx
function App() {
  const name = "테스트";

  return (
    <>
      <h1>name의 값: {name}</h1>
      {name==='테스트'? (
        <h1>테스트입니다.</h1>
      ):(
        null
      )}
    </>
  );
}

export default App;
```
- 위의 코드는 name의 값이 '테스트'이면 화면을 보여주고, '테스트'가 아닐 경우 화면을 보여주지 않는 코드임.
- 위의 내용을 AND 연산자를 사용하여 조건부 렌더링을 할 수 있음.
``` jsx
function App() {
  const name = "테스트";

  return (<>{name === '테스트' && <h1>테스트입니다.</h1>}</>);
}

export default App;
```
- && 연산자로 조건부 렌더링을 할 수 있는 이유는 false일 때 null과 마찬가지로 아무것도 나타나지 않기 때문임.
- <b>주의할 점으로 falsy한 값인 0은 예외적으로 화면에 나타남.</b>
``` jsx
function App() {
  const number = 0;

  return <>{number && <h1>숫자입니다.</h1>}</>;
}

export default App;
```
- 위 코드는 화면에 0을 보여줌.
- JSX를 여러 줄로 작성할 때 괄호로 감싸고, 한 줄로 작성할 때는 생략할 수 있음.
<br>

## 8. undefined를 렌더링하지 않기
- 리액트 컴포넌트에서는 함수에서 undefined만 반환하여 렌더링하는 상활을 만들면 안 됨.
- <b>어떤 값이 undefined일 수도 있다면 OR(||) 연산자를 사용하면 해당 값이 undefined일 때 사용할 값을 지정할 수 있으므로 오류를 방지할 수 있음.</b>
``` jsx
function App() {
  let test = undefined;
  return test || '값이 undefined입니다.';
}

export default App;
```
- undefined일 때 보여주고 싶은 문구가 있다면 다음과 같이 작성
``` jsx
function App() { 
  const test = undefined;
  // test 값이 undefined일 경우 '테스트'를 보여줌.
  return <div>{test || '테스트'}</div>;
} 
 
export default App; 
```
<br>

## 9. 인라인 스타일링
- 리액트에서 DOM 요소에 스타일을 적용할 때는 객체 형태로 넣어주어야 함.
- 스타일중 background-color처럼 - 문자가 포함되어있을 경우 카멜 표기법으로 작성해야함.
``` jsx
function App() { 
  const test = '테스트';
  
  const style = {
    backgroundColor: 'black',
    color: 'aqua',
    fontSize: '48px',
    fontWeight: 'bold',
    padding: 16 // 단위를 생략할 경우 px
  }
  return <div style={style}>{test}</div>;
} 
 
export default App; 
```
- style 변수를 선언하지 않고 사용할 수도 있음.
``` jsx
function App() { 
  const test = '테스트';
  
  return <div 
    style={{
    backgroundColor: 'black',
    color: 'red',
    fontSize: '48px',
    fontWeight: 'bold',
    padding: 16 }}
    >
      {test}
    </div>;
} 
 
export default App; 
```
<br>

### 10. class 대신 className 사용
- 테스트를 위해 App.css의 내용을 수정함.
``` css
.react {
  background: aqua;
  color: black;
  font-size: 48px;
  font-weight: bold;
  padding: 16px;
}
```
- App.js의 내용을 수정
``` jsx
import './App.css';

function App() { 
  const test = '테스트';
  
  return <div className="react">{test} </div>;
} 
 
export default App; 
```
- JSX에서는 class가 아닌 className으로 설정해주어야함.
- class로 설정할 경우에도 스타일은 적용되지만, Console창에 경고가 나타남.
<br>

### 11. 태그를 꼭 닫아야함.
- HTML을 작성할 경우 input태그처럼 꼭 닫지 않아도 정상적으로 작동함.
- JSX에서는 <input></input> 이나 <input/> 처럼 닫아주어야함.
- 태그를 선언하면서 동시에 닫을 수 있는 태그를 self-closing 태그라고 함.
<br>

### 12. 주석
- JSX 내부에서 주석을 작성할 때는 {/* ··· */} 와 같은 형식으로 작성함.
- 시작 태그를 여러 줄로 작성할 경우 그 내부에서 // ···과 같은 형태의 주석도 작성할 수 있음.
- 여러줄로 작성할 수 있음.
``` jsx
import './App.css';

function App() { 
  const test = '주석';
  return (
  <div
    className="react"// 시작 태그가 여러줄 일 경우 이렇게 주석 작성 가능
  >
    {test}
    {/* 주석은 한 줄로도 작성 가능하며 */}
    {/*
    여러 줄로도
    작성가능함
    */}
  </div>);
} 
 
export default App; 
```
